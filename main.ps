# -----------------------------
# PadScript Comprehensive Test
# -----------------------------

# 1. Function Definitions
# -----------------------

# Define a function to calculate the square of a number
MAKE_BIG_BLOCK square<WHOLE_NUMBER>(n<WHOLE_NUMBER>) {
    ADOPT n * n;
}

# Define a function to greet a person
MAKE_BIG_BLOCK greet<WORDS>(name<WORDS>) {
    ADOPT "Hello, " + name + "!";
}

# 2. Class Definition
# --------------------

# Define a class Person with name and age
MAKE_BIGGER_BLOCK Person(name<WORDS>, age<WHOLE_NUMBER>) {
    # No methods, just attributes
    # Attributes are initialized via the constructor
}

# 3. Variable Declarations
# -------------------------

# Create a list of Person instances
uh people<MORE_WORDS> = [
    Person("Alice", 30),
    Person("Bob", 17),
    Person("Charlie", 25),
    Person("Diana", 15)
];

# 4. Looping Through the List
# ----------------------------

# Iterate over the list and display information about each person
LOOP_COOL : grab person from people {
    # Print the person's name and age
    pad("Name: " + person.name + ", Age: " + person.age);
    
    # Conditional Checks
    do(person.age >= 18) {
        pad(person.name + " is an adult.");
    }
    do_not_work(person.age < 18) {
        pad(person.name + " is a minor.");
    }
    do_not_work_not_work {
        pad("This block should not execute.");
    }
}

# 5. User Input to Add a New Person
# ----------------------------------

# Prompt the user to enter the name of a new person
uh new_name<WORDS> = pad_in("Enter the name of the new person: ");

# Prompt the user to enter the age of the new person
uh new_age_input<WORDS> = pad_in("Enter the age of the new person: ");

# Convert the user input to a WHOLE_NUMBER
# Assuming the interpreter handles casting during variable assignment
uh new_age<WHOLE_NUMBER> = new_age_input;

# Create a new Person instance with the provided name and age
uh new_person<Person> = Person(new_name, new_age);

# Since 'append' is not implemented, we cannot add to the existing list
# Instead, we'll display the newly added person separately
pad("Added new person: " + new_person.name + ", Age: " + new_person.age);

# Conditional Blocks to Demonstrate Control Structures
do(new_person.age >= 18) {
    pad(new_person.name + " is now an adult.");
}
do_not_work(new_person.age < 18) {
    pad(new_person.name + " is still a minor.");
}
do_not_work_not_work {
    pad("This else block should not execute.");
}

# 6. Constants and Arithmetic Expressions
# ---------------------------------------

# Define a constant PI
huh PI<NOT_NICE_NUMBER> = 3.14159;

# Calculate the circumference of a circle with radius 2 using PI
uh circumference<NOT_NICE_NUMBER> = PI * 2;

# Print the circumference
pad("Circumference: " + circumference);

# 7. Utilizing Built-in Functions
# -------------------------------

# Use the 'greet' function to greet a person
uh greeting<WORDS> = greet("Eve");
pad(greeting);

# 8. Additional Control Flow Tests
# --------------------------------

# Define a list of numbers
uh numbers<MORE_WHOLE_NUMBER> = [1, 2, 3, 4, 5];

# Iterate over the numbers and print their squares
LOOP_COOL : grab num from numbers {
    # Calculate square using the 'square' function
    uh squared<WHOLE_NUMBER> = square(num);
    pad("Square of " + num + " is " + squared);
}

# Use conditional statements to check multiple conditions
uh test_num<WHOLE_NUMBER> = 10;

do(test_num > 0) {
    pad("test_num is positive.");
}
do_not_work(test_num < 0) {
    pad("test_num is negative.");
}
do_not_work_not_work {
    pad("test_num is zero.");
}

# 9. Nested Functions and Control Structures
# ------------------------------------------

# Define a function that uses another function
MAKE_BIG_BLOCK compute_and_greet<WORDS>(num<WHOLE_NUMBER>, name<WORDS>) {
    # Compute the square of the number
    uh result<WHOLE_NUMBER> = square(num);
    
    # Greet the person with their name and computed result
    uh message<WORDS> = greet(name) + " Your number squared is " + result;
    ADOPT message;
}

# Call the nested function
uh nested_greeting<WORDS> = compute_and_greet(5, "Frank");
pad(nested_greeting);

# 10. Final Loop to Demonstrate Multiple Features
# -----------------------------------------------

# Iterate over the list of people again to display updated information
LOOP_COOL : grab person from people {
    pad("Name: " + person.name + ", Age: " + person.age);
    
    do(person.age >= 18) {
        pad(person.name + " continues to be an adult.");
    }
    do_not_work(person.age < 18) {
        pad(person.name + " continues to be a minor.");
    }
    do_not_work_not_work {
        pad("This block should not execute.");
    }
}

uh number_list<MORE_WHOLE_NUMBER> = [10, 20, 30, 40, 50, 43, 57];

LOOP_COOL : grab num from number_list {
    do(num % 2 == 0) {
        pad(num + " is even.");
    }
    do_not_work_not_work {
        pad(num + " is odd.");
    }
}


# End of Test Script